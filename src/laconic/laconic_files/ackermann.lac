/* ackermann function */

func decr(x) {
    x = x - 1;
    return;
}

func incr(x) {
    x = x + 1;
    return;
}

/* add an element i into stack s */
func stack_add(s, i) {
     s = s^i;
     return;
}

/* pop element from stask s */
/* element is the element poped*/
func stack_pop(l, t, n, size, element) {
  n = 0;
  t = [];
  size = #l;
  decr(size);
  while ( n < size ) {
      element = l@n;
      t = t^element;
      incr(n);
  }
  element = l@n;
  l = t;
  return;
}

func ackermann(m, n, l, t, i, index, size, element, original_m, original_n) {
    original_m = m;
    original_n = n;
    stack_add(l, m);
    size = #l;
    while (size > 0){
      stack_pop(l, t, index, size, element);
      print l;
      print element;
      decr(size);
      m = element;
      if( original_m==0 ){
          n = n + m + 1;
      }
      if( original_m >0 & original_n==0 ){
          incr(n);
          decr(m);
          stack_add(l, m);
          size = size + 1;
      }
      if(original_m > 0 & original_n >0){
          print original_m;
          decr(m);
          stack_add(l, m);
          size = size + 1;
          m = m + 1;
          stack_add(l, m);
          size = size + 1;
          decr(n);
      }
      original_m = m;
      original_n = n;
    }
    return;
}


list l;
list t;
int index;
int size;
int i;
int element;
int m;
int n;
int original_m;
int original_n;

m = 10;
n = 2;
n = n + 1;

l = [];
t = [];

ackermann(m, n, l, t, i, index, size, element, original_m, original_n);
print n;

halt;
